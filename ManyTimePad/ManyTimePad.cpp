// ManyTimePad.cpp : Defines the entry point for the console application.
//

#include "stdafx.h"

// Resources
static unsigned char ciphertext_1[] = {0x31, 0x5C, 0x4E, 0xEA, 0xA8, 0xB5, 0xF8, 0xAA, 0xF9, 0x17, 0x41, 0x45, 0xBF, 0x43, 0xE1, 0x78, 0x4B, 0x8F, 0xA0, 0x0D, 0xC7, 0x1D, 0x88, 0x5A, 0x80, 0x4E, 0x5E, 0xE9, 0xFA, 0x40, 0xB1, 0x63, 0x49, 0xC1, 0x46, 0xFB, 0x77, 0x8C, 0xDF, 0x2D, 0x3A, 0xFF, 0x02, 0x1D, 0xFF, 0xF5, 0xB4, 0x03, 0xB5, 0x10, 0xD0, 0xD0, 0x45, 0x54, 0x68, 0xAE, 0xB9, 0x86, 0x22, 0xB1, 0x37, 0xDA, 0xE8, 0x57, 0x55, 0x3C, 0xCD, 0x88, 0x83, 0xA7, 0xBC, 0x37, 0x52, 0x0E, 0x06, 0xE5, 0x15, 0xD2, 0x2C, 0x95, 0x4E, 0xBA, 0x50, 0x25, 0xB8, 0xCC, 0x57, 0xEE, 0x59, 0x41, 0x8C, 0xE7, 0xDC, 0x6B, 0xC4, 0x15, 0x56, 0xBD, 0xB3, 0x6B, 0xBC, 0xA3, 0xE8, 0x77, 0x43, 0x01, 0xFB, 0xCA, 0xA3, 0xB8, 0x3B, 0x22, 0x08, 0x09, 0x56, 0x09, 0x87, 0x81, 0x5F, 0x65, 0x28, 0x67, 0x64, 0x70, 0x3D, 0xE0, 0xF3, 0xD5, 0x24, 0x40, 0x0A, 0x19, 0xB1, 0x59, 0x61, 0x0B, 0x11, 0xEF, 0x3E};
static unsigned char ciphertext_2[] = {0x23, 0x4C, 0x02, 0xEC, 0xBB, 0xFB, 0xAF, 0xA3, 0xED, 0x18, 0x51, 0x0A, 0xBD, 0x11, 0xFA, 0x72, 0x4F, 0xCD, 0xA2, 0x01, 0x8A, 0x1A, 0x83, 0x42, 0xCF, 0x06, 0x4B, 0xBD, 0xE5, 0x48, 0xB1, 0x2B, 0x07, 0xDF, 0x44, 0xBA, 0x71, 0x91, 0xD9, 0x60, 0x6E, 0xF4, 0x08, 0x1F, 0xFD, 0xE5, 0xAD, 0x46, 0xA5, 0x06, 0x9D, 0x9F, 0x7F, 0x54, 0x3B, 0xED, 0xB9, 0xC8, 0x61, 0xBF, 0x29, 0xC7, 0xE2, 0x05, 0x13, 0x2E, 0xDA, 0x93, 0x82, 0xB0, 0xBC, 0x2C, 0x5C, 0x4B, 0x45, 0xF9, 0x19, 0xCF, 0x3A, 0x9F, 0x1C, 0xB7, 0x41, 0x51, 0xF6, 0xD5, 0x51, 0xF4, 0x48, 0x0C, 0x82, 0xB2, 0xCB, 0x24, 0xCC, 0x5B, 0x02, 0x8A, 0xA7, 0x6E, 0xB7, 0xB4, 0xAB, 0x24, 0x17, 0x1A, 0xB3, 0xCD, 0xAD, 0xB8, 0x35, 0x6F};
static unsigned char ciphertext_3[] = {0x32, 0x51, 0x0B, 0xA9, 0xA7, 0xB2, 0xBB, 0xA9, 0xB8, 0x00, 0x5D, 0x43, 0xA3, 0x04, 0xB5, 0x71, 0x4C, 0xC0, 0xBB, 0x0C, 0x8A, 0x34, 0x88, 0x4D, 0xD9, 0x13, 0x04, 0xB8, 0xAD, 0x40, 0xB6, 0x2B, 0x07, 0xDF, 0x44, 0xBA, 0x6E, 0x9D, 0x8A, 0x23, 0x68, 0xE5, 0x1D, 0x04, 0xE0, 0xE7, 0xB2, 0x07, 0xB7, 0x0B, 0x9B, 0x82, 0x61, 0x11, 0x2B, 0xAC, 0xB6, 0xC8, 0x66, 0xA2, 0x32, 0xDF, 0xE2, 0x57, 0x52, 0x7D, 0xC2, 0x93, 0x98, 0xF5, 0xF3, 0x25, 0x1A, 0x0D, 0x47, 0xE5, 0x03, 0xC6, 0x6E, 0x93, 0x5D, 0xE8, 0x12, 0x30, 0xB5, 0x9B, 0x7A, 0xFB, 0x5F, 0x41, 0xAF, 0xA8, 0xD6, 0x61, 0xCB};
static unsigned char ciphertext_4[] = {0x32, 0x51, 0x0B, 0xA9, 0xAA, 0xB2, 0xA8, 0xA4, 0xFD, 0x06, 0x41, 0x4F, 0xB5, 0x17, 0xB5, 0x60, 0x5C, 0xC0, 0xAA, 0x0D, 0xC9, 0x1A, 0x89, 0x08, 0xC2, 0x06, 0x4B, 0xA8, 0xAD, 0x5E, 0xA0, 0x6A, 0x02, 0x90, 0x56, 0xF4, 0x7A, 0x8A, 0xD3, 0x30, 0x6E, 0xF5, 0x02, 0x1E, 0xAF, 0xE1, 0xAC, 0x01, 0xA8, 0x11, 0x97, 0x84, 0x7A, 0x5C, 0x68, 0xA1, 0xB7, 0x87, 0x69, 0xA3, 0x7B, 0xC8, 0xF4, 0x57, 0x54, 0x32, 0xC1, 0x98, 0xCC, 0xB4, 0xEF, 0x63, 0x59, 0x02, 0x56, 0xE3, 0x05, 0xCD, 0x3A, 0x95, 0x44, 0xEE, 0x41, 0x60, 0xEA, 0xD4, 0x5A, 0xEF, 0x52, 0x04, 0x89, 0xE7, 0xDA, 0x7D, 0x83, 0x54, 0x02, 0xBC, 0xA6, 0x70, 0xBD, 0xA8, 0xEB, 0x77, 0x52, 0x00, 0xB8, 0xDA, 0xBB, 0xBA, 0x24, 0x6B, 0x13, 0x0F, 0x04, 0x0D, 0x8E, 0xC6, 0x44, 0x7E, 0x2C, 0x76, 0x7F, 0x3D, 0x30, 0xED, 0x81, 0xEA, 0x2E, 0x4C, 0x14, 0x04, 0xE1, 0x31, 0x5A, 0x10, 0x10, 0xE7, 0x22, 0x9B, 0xE6, 0x63, 0x6A, 0xAA};
static unsigned char ciphertext_5[] = {0x3F, 0x56, 0x1B, 0xA9, 0xAD, 0xB4, 0xB6, 0xEB, 0xEC, 0x54, 0x42, 0x4B, 0xA3, 0x17, 0xB5, 0x64, 0x41, 0x8F, 0xAC, 0x0D, 0xD3, 0x5F, 0x8C, 0x08, 0xD3, 0x1A, 0x1F, 0xE9, 0xE2, 0x4F, 0xE5, 0x68, 0x08, 0xC2, 0x13, 0xF1, 0x7C, 0x81, 0xD9, 0x60, 0x7C, 0xEE, 0x02, 0x1D, 0xAF, 0xE1, 0xE0, 0x01, 0xB2, 0x1A, 0xDE, 0x87, 0x7A, 0x5E, 0x68, 0xBE, 0xA8, 0x8D, 0x61, 0xB9, 0x3A, 0xC5, 0xEE, 0x0D, 0x56, 0x2E, 0x8E, 0x95, 0x82, 0xF5, 0xEF, 0x37, 0x5F, 0x0A, 0x4A, 0xE2, 0x0E, 0xD8, 0x6E, 0x93, 0x5D, 0xE8, 0x12, 0x30, 0xB5, 0x9B, 0x73, 0xFB, 0x43, 0x02, 0xCD, 0x95, 0xD7, 0x70, 0xC6, 0x5B, 0x40, 0xAA, 0xA0, 0x65, 0xF2, 0xA5, 0xE3, 0x3A, 0x5A, 0x0B, 0xB5, 0xDC, 0xAB, 0xA4, 0x37, 0x22, 0x13, 0x0F, 0x04, 0x2F, 0x8E, 0xC8, 0x5B, 0x7C, 0x20, 0x70};
static unsigned char ciphertext_6[] = {0x32, 0x51, 0x0B, 0xFB, 0xAC, 0xFB, 0xB9, 0xBE, 0xFD, 0x54, 0x41, 0x5D, 0xA2, 0x43, 0xE1, 0x69, 0x5E, 0xCA, 0xBD, 0x58, 0xC5, 0x19, 0xCD, 0x4B, 0xD2, 0x06, 0x1B, 0xBD, 0xE2, 0x4E, 0xB7, 0x6A, 0x19, 0xD8, 0x4A, 0xBA, 0x34, 0xD8, 0xDE, 0x28, 0x7B, 0xE8, 0x4D, 0x07, 0xE7, 0xE9, 0xA3, 0x0E, 0xE7, 0x14, 0x97, 0x9C, 0x7E, 0x11, 0x23, 0xA8, 0xBD, 0x98, 0x22, 0xA3, 0x3E, 0xCA, 0xF5, 0x12, 0x47, 0x2E, 0x8E, 0x8F, 0x8D, 0xB3, 0xF9, 0x63, 0x5C, 0x19, 0x49, 0xE6, 0x40, 0xC6, 0x21, 0x85, 0x4E, 0xBA, 0x0D, 0x79, 0xEC, 0xCF, 0x52, 0xFF, 0x11, 0x12, 0x84, 0xB4, 0xCC, 0x61, 0xD1, 0x19, 0x02, 0xAE, 0xBC, 0x66, 0xF2, 0xB2, 0xE4, 0x36, 0x43, 0x4E, 0xAC, 0xC0, 0xAB, 0xA9, 0x38, 0x22, 0x0B, 0x08, 0x48, 0x00, 0xC2, 0xCA, 0x4E, 0x69, 0x35, 0x22, 0x64, 0x35, 0x73, 0xB2, 0xC4, 0xCE, 0x35, 0x05, 0x0B, 0x0C, 0xF7, 0x74, 0x20, 0x1F, 0x0F, 0xE5, 0x2A, 0xC9, 0xF2, 0x6D, 0x71, 0xB6, 0xCF, 0x61, 0xA7, 0x11, 0xCC, 0x22, 0x9F, 0x77, 0xAC, 0xE7, 0xAA, 0x88, 0xA2, 0xF1, 0x99, 0x83, 0x12, 0x2B, 0x11, 0xBE, 0x87, 0xA5, 0x9C, 0x35, 0x5D, 0x25, 0xF8, 0xE4};
static unsigned char ciphertext_7[] = {0x32, 0x51, 0x0B, 0xFB, 0xAC, 0xFB, 0xB9, 0xBE, 0xFD, 0x54, 0x41, 0x5D, 0xA2, 0x43, 0xE1, 0x69, 0x5E, 0xCA, 0xBD, 0x58, 0xC5, 0x19, 0xCD, 0x4B, 0xD9, 0x0F, 0x1F, 0xA6, 0xEA, 0x5B, 0xA4, 0x7B, 0x01, 0xC9, 0x09, 0xBA, 0x76, 0x96, 0xCF, 0x60, 0x6E, 0xF4, 0x0C, 0x04, 0xAF, 0xE1, 0xAC, 0x0A, 0xA8, 0x14, 0x8D, 0xD0, 0x66, 0x59, 0x2D, 0xED, 0x9F, 0x87, 0x74, 0xB5, 0x29, 0xC7, 0xEA, 0x12, 0x5D, 0x29, 0x8E, 0x88, 0x83, 0xF5, 0xE9, 0x30, 0x5F, 0x4B, 0x44, 0xF9, 0x15, 0xCB, 0x2B, 0xD0, 0x5A, 0xF5, 0x13, 0x73, 0xFD, 0x9B, 0x4A, 0xF5, 0x11, 0x03, 0x9F, 0xA2, 0xD9, 0x6F, 0x83, 0x41, 0x4A, 0xAA, 0xF2, 0x61, 0xBD, 0xA2, 0xE9, 0x7B, 0x17, 0x0F, 0xB5, 0xCC, 0xE2, 0xA5, 0x3E, 0x67, 0x5C, 0x15, 0x4C, 0x0D, 0x96, 0x81, 0x59, 0x69, 0x34, 0x77, 0x7E, 0x22, 0x75, 0xB3, 0x81, 0xCE, 0x2E, 0x40, 0x58, 0x2A, 0xFE, 0x67, 0x65, 0x0B, 0x13, 0xE7, 0x22, 0x87, 0xFF, 0x22, 0x70, 0xAB, 0xCF, 0x73, 0xBB, 0x02, 0x89, 0x32, 0x83, 0x6F, 0xBD, 0xEC, 0xFE, 0xCE, 0xE0, 0xA3, 0xB8, 0x94, 0x47, 0x3C, 0x1B, 0xBE, 0xB6, 0xB4, 0x91, 0x3A, 0x53, 0x6C, 0xE4, 0xF9, 0xB1, 0x3F, 0x1E, 0xFF, 0xF7, 0x1E, 0xA3, 0x13, 0xC8, 0x66, 0x1D, 0xD9, 0xA4, 0xCE};
static unsigned char ciphertext_8[] = {0x31, 0x5C, 0x4E, 0xEA, 0xA8, 0xB5, 0xF8, 0xBF, 0xFD, 0x11, 0x15, 0x5E, 0xA5, 0x06, 0xB5, 0x60, 0x41, 0xC6, 0xA0, 0x0C, 0x8A, 0x08, 0x85, 0x4D, 0xD2, 0x1A, 0x4B, 0xBD, 0xE5, 0x4C, 0xE5, 0x68, 0x01, 0xD9, 0x43, 0xBA, 0x70, 0x8B, 0x8A, 0x35, 0x74, 0xF4, 0x0C, 0x00, 0xFF, 0xF9, 0xE0, 0x0F, 0xA1, 0x43, 0x9F, 0xD0, 0x65, 0x43, 0x27, 0xA3, 0xBF, 0xC8, 0x60, 0xB9, 0x2F, 0x89, 0xEE, 0x04, 0x13, 0x2E, 0xCB, 0x92, 0x98, 0xF5, 0xFD, 0x2D, 0x5E, 0x4B, 0x45, 0xE4, 0x0E, 0xCC, 0x3B, 0x9D, 0x59, 0xE9, 0x41, 0x7D, 0xF7, 0xC9, 0x5B, 0xBA, 0x41, 0x0E, 0x9A, 0xA2, 0xCA, 0x24, 0xC5, 0x47, 0x4D, 0xA2, 0xF2, 0x76, 0xBA, 0xA3, 0xAC, 0x32, 0x59, 0x18, 0xB2, 0xDA, 0xAD, 0xA4, 0x3D, 0x67, 0x12, 0x15, 0x04, 0x41, 0xC2, 0xE0, 0x4F, 0x65, 0x65, 0x51, 0x7F, 0x31, 0x7D, 0xA9, 0xD3};
static unsigned char ciphertext_9[] = {0x27, 0x19, 0x46, 0xF9, 0xBB, 0xB2, 0xAE, 0xAD, 0xEC, 0x11, 0x18, 0x41, 0xA8, 0x1A, 0xBC, 0x30, 0x0E, 0xCA, 0xA0, 0x1B, 0xD8, 0x06, 0x9D, 0x5C, 0xC9, 0x10, 0x05, 0xE9, 0xFE, 0x4A, 0xAD, 0x6E, 0x04, 0xD5, 0x13, 0xE9, 0x6D, 0x99, 0xDE, 0x25, 0x69, 0xBC, 0x5E, 0x50, 0xEE, 0xEC, 0xA7, 0x09, 0xB5, 0x0A, 0x8A, 0x98, 0x7F, 0x42, 0x64, 0xED, 0xB6, 0x89, 0x6F, 0xB5, 0x37, 0xD0, 0xA7, 0x16, 0x13, 0x2D, 0xDC, 0x93, 0x8F, 0xB0, 0xF8, 0x36, 0x48, 0x0E, 0x06, 0xED, 0x0F, 0xCD, 0x6E, 0x97, 0x59, 0xF4, 0x04, 0x62, 0xF9, 0xCF, 0x57, 0xF4, 0x56, 0x41, 0x86, 0xA2, 0xC1, 0x77, 0x8F, 0x15, 0x43, 0xEF, 0xA2, 0x70, 0xBD, 0xA5, 0xE9, 0x33, 0x42, 0x1C, 0xBE, 0x88, 0xA4, 0xA5, 0x22, 0x22, 0x19, 0x0F, 0x47, 0x1E, 0x9B, 0xD1, 0x5F, 0x65, 0x2B, 0x65, 0x3B, 0x70, 0x71, 0xAE, 0xC5, 0x9A, 0x27, 0x05, 0x08, 0x1F, 0xFE, 0x72, 0x65, 0x1D, 0x08, 0xF8, 0x22, 0xC9, 0xED, 0x6D, 0x76, 0xE4, 0x8B, 0x63, 0xAB, 0x15, 0xD0, 0x20, 0x85, 0x73, 0xA7, 0xEE, 0xF0, 0x27};
static unsigned char ciphertext_10[]= {0x46, 0x6D, 0x06, 0xEC, 0xE9, 0x98, 0xB7, 0xA2, 0xFB, 0x1D, 0x46, 0x4F, 0xED, 0x2C, 0xED, 0x76, 0x41, 0xDD, 0xAA, 0x3C, 0xC3, 0x1C, 0x99, 0x41, 0xCF, 0x11, 0x0A, 0xBB, 0xF4, 0x09, 0xED, 0x39, 0x59, 0x80, 0x05, 0xB3, 0x39, 0x9C, 0xCF, 0xAF, 0xB6, 0x1D, 0x03, 0x15, 0xFC, 0xA0, 0xA3, 0x14, 0xBE, 0x13, 0x8A, 0x9F, 0x32, 0x50, 0x3B, 0xED, 0xAC, 0x80, 0x67, 0xF0, 0x3A, 0xDB, 0xF3, 0x57, 0x5C, 0x3B, 0x8E, 0xDC, 0x9B, 0xA7, 0xF5, 0x37, 0x53, 0x05, 0x41, 0xAB, 0x0F, 0x9F, 0x3C, 0xD0, 0x4F, 0xF5, 0x0D, 0x66, 0xF1, 0xD5, 0x59, 0xBA, 0x52, 0x0E, 0x89, 0xA2, 0xCB, 0x2A, 0x83};

static unsigned char ciphertext_target[] = {0x32, 0x51, 0x0B, 0xA9, 0xBA, 0xBE, 0xBB, 0xBE, 0xFD, 0x00, 0x15, 0x47, 0xA8, 0x10, 0xE6, 0x71, 0x49, 0xCA, 0xEE, 0x11, 0xD9, 0x45, 0xCD, 0x7F, 0xC8, 0x1A, 0x05, 0xE9, 0xF8, 0x5A, 0xAC, 0x65, 0x0E, 0x90, 0x52, 0xBA, 0x6A, 0x8C, 0xD8, 0x25, 0x7B, 0xF1, 0x4D, 0x13, 0xE6, 0xF0, 0xA8, 0x03, 0xB5, 0x4F, 0xDE, 0x9E, 0x77, 0x47, 0x2D, 0xBF, 0xF8, 0x9D, 0x71, 0xB5, 0x7B, 0xDD, 0xEF, 0x12, 0x13, 0x36, 0xCB, 0x85, 0xCC, 0xB8, 0xF3, 0x31, 0x5F, 0x4B, 0x52, 0xE3, 0x01, 0xD1, 0x6E, 0x9F, 0x52, 0xF9, 0x04};

static unsigned char english_frequent[114][20] = {" the ",
                                                 " be ",
											     " and ",
											     " of ",
											     " a ",
											     " in ",
												 " that ",
											     " have ",
											     " it ",
												 " for ",
												 " not ",
												 " on ",
												 " with ",
												 " he ",
												 " as ",
												 " you ",
												 " do ",
												 " at ",
												 " this ",
												 " but ",
												 " his ",
												 " by ",
												 " from ",
												 " they ",
												 " we ",
												 " say ",
												 " her ",
												 " she ",
												 " or ",
											     " an ",
												 " will ",
                                                 " my ",
                                                 " one ",
                                                 " all ",
												 " would ",
												 " there ",
												 " their ",
												 " what ",
												 " so ",
												 " up ",
												 " out ",
												 " if ",
												 " about ",
												 " who ",
												 " get ",
												 " which ",
												 " go ",
												 " me ",
												 " when ",
												 " make ",
												 " can ",
												 " like ",
												 " time ",
												 " no ",
												 " just ",
												 " him ",
												 " know ",
												 " take ",
												 " people ",
												 " into ",
												 " year ",
												 " your ",
												 " good ",
												 " some ",
												 " could ",
												 " them ",
												 " see ",
												 " other ",
												 " than ",
												 " then ",
												 " now ",
												 " look ",
												 " only ",
												 " come ",
												 " its ",
												 " over ",
												 " think ",
												 " also ",
												 " back ",
												 " after ",
												 " use ",
												 " two ",
												 " how ",
												 " our ",
												 " work ",
												 " first ",
												 " well ",
												 " way ",
												 " even ",
												 " new ",
												 " want ",
												 " because ",
												 " any ",
												 " these ",
												 " give ",
												 " day ",
												 " most ",
												 " us ",
												 " xor ",
												 " buffer ",
												 " encryption ",
												 " crypto ",
												 " cryptography ",
												 " plaintext ",
												 " ciphertext ",
												 " key ",
												 " p=",
												 " q=",
												 " xor ", 
												 " XOR ",
												 " OTP ",
												 " otp ",
												 " computer ",
												 " computed ", // 114
};

static const int max_len = ('z' - 'a' + 1) + ('Z' -'A' + 1) + 1;

inline size_t min(size_t a, size_t b)
{
	return (a<b?a:b);
}

char GeradorCaracteres()
{	
#ifdef _INCLUDE_NUMBERS
	static int curr_pos = '0';
#else
	static int curr_pos = 'A';
#endif

	char ret;

	ret = curr_pos;
#ifdef _INCLUDE_NUMBERS
	if(curr_pos == '9')
	{
		curr_pos = 'A';
	}
	else if(curr_pos == 'Z')
#else
	if(curr_pos == 'Z')
#endif
	{
		curr_pos = 'a';
	}
	else if ( curr_pos == 'z' )
	{
		curr_pos = 'A';
	}
	else
	{
		curr_pos++;
	}

	return ret;
}

void ImprimeArquivo(unsigned char* mensagem, size_t tamanho, bool bHexa = false)
{
	std::ofstream oArquivo;

	oArquivo.open("console.txt", std::ios::app);
		for(size_t i=0; i<tamanho; i++)
		(bHexa?oArquivo << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << (int) mensagem[i]: oArquivo << mensagem[i]);

	oArquivo << std::endl;

	oArquivo.close();
}

void ImprimeMensagem(unsigned char* mensagem, size_t tamanho, bool bHexa = false, bool bArquivo = false)
{
	for(size_t i=0; i<tamanho; i++)
		(bHexa?std::cout << std::hex << std::setw(2) << std::setfill('0') << std::uppercase << (int) mensagem[i]: std::cout << mensagem[i]);

	if (bArquivo)
		ImprimeArquivo(mensagem, tamanho, bHexa);
}

std::vector<char> & crossvector_xor(std::vector<char> & vec_a, std::vector<char> & vec_b)
{
	std::vector<char> *vetorcruzado = new std::vector<char>(min(vec_a.size(), vec_b.size()));
	for(int n=0; n<vetorcruzado->size(); n++)
	{
		vetorcruzado->at(n) = vec_a.at(n) ^ vec_b.at(n);
	}
	return *vetorcruzado;
}

void singlebyte_xor(void * buffer, char c, size_t tamanho)
{
	char* pBuffer = (char*) buffer;
	for ( size_t i=0; i<tamanho; i++ )
	{
		pBuffer[i] = (char)(pBuffer[i] ^ c);
	}
}

void buffer_xor(void * buffer, void * xoring_buffer, size_t tamanho_x)
{
	char* pBuffer = (char*) buffer;
	char* pXor    = (char*) xoring_buffer;
	for (int i=0; i<tamanho_x; i++)
	{
		pBuffer[i] = (char)(pBuffer[i] ^ pXor[i]);
	}
}

int main(int argc, char* argv[])
{
	std::list<std::vector<char>> *mensagens_cruzadas = new std::list<std::vector<char>>();
	std::vector<char> *xorchars = new std::vector<char>(max_len);

	std::vector<char> * vetor_cifradas_t = new std::vector<char>(ciphertext_target, ciphertext_target + sizeof(ciphertext_target));
	std::vector<char> * vetor_cifradas_1 = new std::vector<char>(ciphertext_1, ciphertext_1 + sizeof(ciphertext_1));
	std::vector<char> * vetor_cifradas_2 = new std::vector<char>(ciphertext_2, ciphertext_2 + sizeof(ciphertext_2));
	std::vector<char> * vetor_cifradas_3 = new std::vector<char>(ciphertext_3, ciphertext_3 + sizeof(ciphertext_3));
	std::vector<char> * vetor_cifradas_4 = new std::vector<char>(ciphertext_4, ciphertext_4 + sizeof(ciphertext_4));
	std::vector<char> * vetor_cifradas_5 = new std::vector<char>(ciphertext_5, ciphertext_5 + sizeof(ciphertext_5));
	std::vector<char> * vetor_cifradas_6 = new std::vector<char>(ciphertext_6, ciphertext_6 + sizeof(ciphertext_6));
	std::vector<char> * vetor_cifradas_7 = new std::vector<char>(ciphertext_7, ciphertext_7 + sizeof(ciphertext_7));
	std::vector<char> * vetor_cifradas_8 = new std::vector<char>(ciphertext_8, ciphertext_8 + sizeof(ciphertext_8));
	std::vector<char> * vetor_cifradas_9 = new std::vector<char>(ciphertext_9, ciphertext_9 + sizeof(ciphertext_9));
	std::vector<char> * vetor_cifradas_10= new std::vector<char>(ciphertext_10,ciphertext_10+ sizeof(ciphertext_10));
	
	std::vector<char> & cross_cifradas_1 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_1);
	std::vector<char> & cross_cifradas_2 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_2);
	std::vector<char> & cross_cifradas_3 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_3);
	std::vector<char> & cross_cifradas_4 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_4);
	std::vector<char> & cross_cifradas_5 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_5);
	std::vector<char> & cross_cifradas_6 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_6);
	std::vector<char> & cross_cifradas_7 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_7);
	std::vector<char> & cross_cifradas_8 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_8);
	std::vector<char> & cross_cifradas_9 = crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_9);
	std::vector<char> & cross_cifradas_10= crossvector_xor(*vetor_cifradas_t, *vetor_cifradas_10);
	
	mensagens_cruzadas->push_back(cross_cifradas_1);
	mensagens_cruzadas->push_back(cross_cifradas_2);
	mensagens_cruzadas->push_back(cross_cifradas_3);
	mensagens_cruzadas->push_back(cross_cifradas_4);
	mensagens_cruzadas->push_back(cross_cifradas_5);
	mensagens_cruzadas->push_back(cross_cifradas_6);
	mensagens_cruzadas->push_back(cross_cifradas_7);
	mensagens_cruzadas->push_back(cross_cifradas_8);
	mensagens_cruzadas->push_back(cross_cifradas_9);
	mensagens_cruzadas->push_back(cross_cifradas_10);

	int tamanho_forca_bruta = min( cross_cifradas_1.size(),
								   min(cross_cifradas_2.size(),
								   min(cross_cifradas_3.size(), 
								   min(cross_cifradas_4.size(),
								   min(cross_cifradas_5.size(),
								   min(cross_cifradas_6.size(),
								   min(cross_cifradas_7.size(),
								   min(cross_cifradas_8.size(),
								   min(cross_cifradas_9.size(), cross_cifradas_10.size())))))))));

	// Gera a lista de caracteres a-zA-Z
	std::generate(xorchars->begin(), xorchars->end(), GeradorCaracteres);

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// 1a metodologia: crib-dragging
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	for ( std::vector<char> & m : *mensagens_cruzadas )
	{
		static int n = 1;
		std::string str = "-----------------------------------------------------------------------------------------\n";
		
		str += "Método crib-dragging para a mensagem " + std::to_string(n++) + ":\n";

		ImprimeMensagem((unsigned char*)str.c_str(), str.size(), false, true);
		for ( int i=0; i<114; i++ )
		{

			unsigned char* pXoringBuffer = &english_frequent[i][0];

			std::string strPalavra = "Testando contra a palavra [" + std::string((char*)pXoringBuffer) + "] : \n\n";
			ImprimeMensagem((unsigned char*)strPalavra.c_str(), strPalavra.size(), false, true);

			for ( int offset = 0; offset<tamanho_forca_bruta; offset++ )
			{
				std::string strXoredBuffer;

				int iTamanhoXor = min(strlen((const char*)pXoringBuffer), (tamanho_forca_bruta - offset));
				std::vector<char> buffer(0);
				std::copy( cross_cifradas_1.begin() + offset, 
				           cross_cifradas_1.begin() + offset + iTamanhoXor,
				   		   std::back_inserter(buffer));

				for ( int fill=0; fill<offset; fill++)
					strXoredBuffer += " ";

				buffer_xor(buffer.data(), pXoringBuffer, iTamanhoXor);

				for ( int j=0; j<buffer.size(); j++ )
					strXoredBuffer += buffer.data()[j];

				ImprimeMensagem((unsigned char*)strXoredBuffer.c_str(), strXoredBuffer.size(), false, true);
			}
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// 2a metodologia: análise de caracteres
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	std::vector<std::vector<char> *>  lista_possibilidades(tamanho_forca_bruta);
	for ( int i=0; i<tamanho_forca_bruta; i++) {
		lista_possibilidades.at(i) = new std::vector<char>(0);
	}
	
	for ( std::vector<char> & v : *mensagens_cruzadas )
	{
		static int n = 1;

		for ( int k=0; k<tamanho_forca_bruta; k++ )		
		{			
			// 1a possibilidade "espaço"
			if ( v.at(k) == 0x00 )
			{
				if ( lista_possibilidades.at(k)->end() == 
					 std::find(lista_possibilidades.at(k)->begin(),
					           lista_possibilidades.at(k)->end(),
							   ' ' ) )
				{
					lista_possibilidades.at(k)->push_back(' ');
				}
			}

			else if ( xorchars->end() != std::find(xorchars->begin(), xorchars->end(), v.at(k)) )
			{
				if ( lista_possibilidades.at(k)->end() == 
					 std::find(lista_possibilidades.at(k)->begin(),
					           lista_possibilidades.at(k)->end(),
							   ' ' ) )
				{
					lista_possibilidades.at(k)->push_back(' ');
				}
			}
			else
			{
				if ( lista_possibilidades.at(k)->end() != 
					 std::find(lista_possibilidades.at(k)->begin(),
					           lista_possibilidades.at(k)->end(),
							   ' ' ) )
				{
					lista_possibilidades.at(k)->erase(std::find(lista_possibilidades.at(k)->begin(),
													   		    lista_possibilidades.at(k)->end(),
																' ' ) );
				}
			}

			// 2a possibilidade "letra"
			if ( v.at(k) > 0x00 && v.at(k) <= 0x1B )
			{
				// Pode ser uma letra com a mesma caixa
				for ( char c : *xorchars )
				{
					char xor_res = v.at(k) ^ c;
					if ( (c >= 0x41 && c <= 0x5A ) &&
						 ( xor_res >= 0x41 && xor_res <= 0x5A ) )
					{
						if ( lista_possibilidades.at(k)->end() == 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->push_back(c);
						}
					}
					else if ( (c >= 0x61 && c <= 0x7A ) &&
						 ( xor_res >= 0x61 && xor_res <= 0x7A ) )
					{
						if ( lista_possibilidades.at(k)->end() == 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->push_back(c);
						}
					}
					else
					{
						if ( lista_possibilidades.at(k)->end() != 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->erase(std::find(lista_possibilidades.at(k)->begin(),
							  					   		      lista_possibilidades.at(k)->end(),
															  c ) );
						}
					}
				}
			} 
			else if ( v.at(k) > 0x20 && v.at(k) <= 0x3B )
			{
				// Pode ser uma letra com caixa invertida
				for ( char c : *xorchars )
				{
					char xor_res = v.at(k) ^ c;
					if ( (c >= 0x41 && c <= 0x5A ) &&
						 ( xor_res >= 0x61 && xor_res <= 0x7A ) )
					{
						if ( lista_possibilidades.at(k)->end() == 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->push_back(c);
						}
					}
					else if ( (c >= 0x61 && c <= 0x7A ) &&
						 ( xor_res >= 0x41 && xor_res <= 0x5A ) )
					{
						if ( lista_possibilidades.at(k)->end() == 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->push_back(c);
						}
					}
					else
					{
						if ( lista_possibilidades.at(k)->end() != 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c ) )
						{
							lista_possibilidades.at(k)->erase(std::find(lista_possibilidades.at(k)->begin(),
							  					   		      lista_possibilidades.at(k)->end(),
															  c ) );
						}
					}
				}
			} 
			else 
			{
				for ( char c : *xorchars )
				{
					char xor_res = v.at(k) ^ c;
					if ( xor_res == (c^0x20) )
					{
						if ( lista_possibilidades.at(k)->end() == 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c^0x20 ) )
						{
							lista_possibilidades.at(k)->push_back(c^0x20);
						}
					}
					else
					{
						if ( lista_possibilidades.at(k)->end() != 
							 std::find(lista_possibilidades.at(k)->begin(),
									   lista_possibilidades.at(k)->end(),
									   c^0x20 ) )
						{
							lista_possibilidades.at(k)->erase(std::find(lista_possibilidades.at(k)->begin(),
							  					   		      lista_possibilidades.at(k)->end(),
															  c^0x20 ) );
						}
					}
				}
			}

		}

		std::cout << std::endl << std::endl;
	}

	for ( std::vector<char> *p : lista_possibilidades )
	{
		static int pos = 0;
		std::cout << std::setw(2) << std::setfill('0') << pos << "("  << p->size() << "):";

		for ( int n=0; n<p->size(); n++ )
		{
			std::cout << p->at(n) << ",";
		}

		std::cout << std::endl;
		pos++;
	}

	return 0;
}
